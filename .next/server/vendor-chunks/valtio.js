"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valtio";
exports.ids = ["vendor-chunks/valtio"];
exports.modules = {

/***/ "(ssr)/./node_modules/valtio/esm/react.mjs":
/*!*******************************************!*\
  !*** ./node_modules/valtio/esm/react.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSnapshot: () => (/* binding */ useSnapshot)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.js\");\n/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! valtio/vanilla */ \"(ssr)/./node_modules/valtio/esm/vanilla.mjs\");\n\n\n\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    pathList.current = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_1__.affectedToPathList)(state, affected, true);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(pathList.current);\n};\nconst condUseAffectedDebugValue = useAffectedDebugValue;\nconst targetCache = /* @__PURE__ */ new WeakMap();\nfunction useSnapshot(proxyObject, options) {\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const affected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => proxyObject && /* @__PURE__ */ new WeakMap(),\n    [proxyObject]\n  );\n  const lastSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n  let inRender = true;\n  const currSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (callback) => {\n        const unsub = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__.subscribe)(proxyObject, callback, notifyInSync);\n        callback();\n        return unsub;\n      },\n      [proxyObject, notifyInSync]\n    ),\n    () => {\n      const nextSnapshot = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__.snapshot)(proxyObject);\n      try {\n        if (!inRender && lastSnapshot.current && !(0,proxy_compare__WEBPACK_IMPORTED_MODULE_1__.isChanged)(\n          lastSnapshot.current,\n          nextSnapshot,\n          affected,\n          /* @__PURE__ */ new WeakMap()\n        )) {\n          return lastSnapshot.current;\n        }\n      } catch (e) {\n      }\n      return nextSnapshot;\n    },\n    () => (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__.snapshot)(proxyObject)\n  );\n  inRender = false;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    lastSnapshot.current = currSnapshot;\n  });\n  if (( false ? 0 : void 0) !== \"production\") {\n    condUseAffectedDebugValue(currSnapshot, affected);\n  }\n  const proxyCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);\n  return (0,proxy_compare__WEBPACK_IMPORTED_MODULE_1__.createProxy)(currSnapshot, affected, proxyCache, targetCache);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS9yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzSDtBQUMzQztBQUN0Qjs7QUFFckQ7QUFDQSxtQkFBbUIsNkNBQU07QUFDekIsRUFBRSxnREFBUztBQUNYLHVCQUF1QixpRUFBa0I7QUFDekMsR0FBRztBQUNILEVBQUUsb0RBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBTTtBQUM3QjtBQUNBLHVCQUF1QiwyREFBb0I7QUFDM0MsSUFBSSxrREFBVztBQUNmO0FBQ0Esc0JBQXNCLHlEQUFTO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFRO0FBQ25DO0FBQ0Esa0RBQWtELHdEQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsVUFBVSx3REFBUTtBQUNsQjtBQUNBO0FBQ0EsRUFBRSxzREFBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0EscUJBQXFCLDhDQUFPO0FBQzVCLFNBQVMsMERBQVc7QUFDcEI7O0FBRXVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEhQXFxEZXNrdG9wXFxib29naWVib3QtbWFpblxcbmV4dC1zb2xhbmEtYXBwLXJvdXRlclxcbm9kZV9tb2R1bGVzXFx2YWx0aW9cXGVzbVxccmVhY3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8sIHVzZVJlZiwgdXNlU3luY0V4dGVybmFsU3RvcmUsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzQ2hhbmdlZCwgY3JlYXRlUHJveHksIGFmZmVjdGVkVG9QYXRoTGlzdCB9IGZyb20gJ3Byb3h5LWNvbXBhcmUnO1xuaW1wb3J0IHsgc3Vic2NyaWJlLCBzbmFwc2hvdCB9IGZyb20gJ3ZhbHRpby92YW5pbGxhJztcblxuY29uc3QgdXNlQWZmZWN0ZWREZWJ1Z1ZhbHVlID0gKHN0YXRlLCBhZmZlY3RlZCkgPT4ge1xuICBjb25zdCBwYXRoTGlzdCA9IHVzZVJlZih2b2lkIDApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHBhdGhMaXN0LmN1cnJlbnQgPSBhZmZlY3RlZFRvUGF0aExpc3Qoc3RhdGUsIGFmZmVjdGVkLCB0cnVlKTtcbiAgfSk7XG4gIHVzZURlYnVnVmFsdWUocGF0aExpc3QuY3VycmVudCk7XG59O1xuY29uc3QgY29uZFVzZUFmZmVjdGVkRGVidWdWYWx1ZSA9IHVzZUFmZmVjdGVkRGVidWdWYWx1ZTtcbmNvbnN0IHRhcmdldENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB1c2VTbmFwc2hvdChwcm94eU9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCBub3RpZnlJblN5bmMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN5bmM7XG4gIGNvbnN0IGFmZmVjdGVkID0gdXNlTWVtbyhcbiAgICAoKSA9PiBwcm94eU9iamVjdCAmJiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBbcHJveHlPYmplY3RdXG4gICk7XG4gIGNvbnN0IGxhc3RTbmFwc2hvdCA9IHVzZVJlZih2b2lkIDApO1xuICBsZXQgaW5SZW5kZXIgPSB0cnVlO1xuICBjb25zdCBjdXJyU25hcHNob3QgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICB1c2VDYWxsYmFjayhcbiAgICAgIChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YiA9IHN1YnNjcmliZShwcm94eU9iamVjdCwgY2FsbGJhY2ssIG5vdGlmeUluU3luYyk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICAgIH0sXG4gICAgICBbcHJveHlPYmplY3QsIG5vdGlmeUluU3luY11cbiAgICApLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IG5leHRTbmFwc2hvdCA9IHNuYXBzaG90KHByb3h5T2JqZWN0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaW5SZW5kZXIgJiYgbGFzdFNuYXBzaG90LmN1cnJlbnQgJiYgIWlzQ2hhbmdlZChcbiAgICAgICAgICBsYXN0U25hcHNob3QuY3VycmVudCxcbiAgICAgICAgICBuZXh0U25hcHNob3QsXG4gICAgICAgICAgYWZmZWN0ZWQsXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICAgICAgKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0U25hcHNob3QuY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbiAgICB9LFxuICAgICgpID0+IHNuYXBzaG90KHByb3h5T2JqZWN0KVxuICApO1xuICBpblJlbmRlciA9IGZhbHNlO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxhc3RTbmFwc2hvdC5jdXJyZW50ID0gY3VyclNuYXBzaG90O1xuICB9KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uZFVzZUFmZmVjdGVkRGVidWdWYWx1ZShjdXJyU25hcHNob3QsIGFmZmVjdGVkKTtcbiAgfVxuICBjb25zdCBwcm94eUNhY2hlID0gdXNlTWVtbygoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgW10pO1xuICByZXR1cm4gY3JlYXRlUHJveHkoY3VyclNuYXBzaG90LCBhZmZlY3RlZCwgcHJveHlDYWNoZSwgdGFyZ2V0Q2FjaGUpO1xufVxuXG5leHBvcnQgeyB1c2VTbmFwc2hvdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/valtio/esm/vanilla.mjs":
/*!*********************************************!*\
  !*** ./node_modules/valtio/esm/vanilla.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   unstable_getInternalStates: () => (/* binding */ unstable_getInternalStates),\n/* harmony export */   unstable_replaceInternalFunction: () => (/* binding */ unstable_replaceInternalFunction)\n/* harmony export */ });\n/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ \"(ssr)/./node_modules/proxy-compare/dist/index.js\");\n\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst canProxyDefault = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);\nconst createSnapshotDefault = (target, version) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const { enumerable } = Reflect.getOwnPropertyDescriptor(\n      target,\n      key\n    );\n    const desc = {\n      value,\n      enumerable,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(\n        value\n      );\n      desc.value = createSnapshotDefault(target2, ensureVersion());\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n};\nconst createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({\n  deleteProperty(target, prop) {\n    const prevValue = Reflect.get(target, prop);\n    removePropListener(prop);\n    const deleted = Reflect.deleteProperty(target, prop);\n    if (deleted) {\n      notifyUpdate([\"delete\", [prop], prevValue]);\n    }\n    return deleted;\n  },\n  set(target, prop, value, receiver) {\n    const hasPrevValue = !isInitializing() && Reflect.has(target, prop);\n    const prevValue = Reflect.get(target, prop, receiver);\n    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n      return true;\n    }\n    removePropListener(prop);\n    if (isObject(value)) {\n      value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;\n    }\n    const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;\n    addPropListener(prop, nextValue);\n    Reflect.set(target, prop, nextValue, receiver);\n    notifyUpdate([\"set\", [prop], value, prevValue]);\n    return true;\n  }\n});\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst snapCache = /* @__PURE__ */ new WeakMap();\nconst versionHolder = [1, 1];\nconst proxyCache = /* @__PURE__ */ new WeakMap();\nlet objectIs = Object.is;\nlet newProxy = (target, handler) => new Proxy(target, handler);\nlet canProxy = canProxyDefault;\nlet createSnapshot = createSnapshotDefault;\nlet createHandler = createHandlerDefault;\nfunction proxy(baseObject = {}) {\n  if (!isObject(baseObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(baseObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propValue) => {\n    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);\n    if (propProxyState) {\n      if (( false ? 0 : void 0) !== \"production\" && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n      if (listeners.size) {\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (( false ? 0 : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  let initializing = true;\n  const handler = createHandler(\n    () => initializing,\n    addPropListener,\n    removePropListener,\n    notifyUpdate\n  );\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(baseObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(baseObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      baseObject,\n      key\n    );\n    if (\"value\" in desc && desc.writable) {\n      proxyObject[key] = baseObject[key];\n    }\n  });\n  initializing = false;\n  return proxyObject;\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (( false ? 0 : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[2];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (( false ? 0 : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion] = proxyState;\n  return createSnapshot(target, ensureVersion());\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nfunction unstable_getInternalStates() {\n  return {\n    proxyStateMap,\n    refSet,\n    snapCache,\n    versionHolder,\n    proxyCache\n  };\n}\nfunction unstable_replaceInternalFunction(name, fn) {\n  switch (name) {\n    case \"objectIs\":\n      objectIs = fn(objectIs);\n      break;\n    case \"newProxy\":\n      newProxy = fn(newProxy);\n      break;\n    case \"canProxy\":\n      canProxy = fn(canProxy);\n      break;\n    case \"createSnapshot\":\n      createSnapshot = fn(createSnapshot);\n      break;\n    case \"createHandler\":\n      createHandler = fn(createHandler);\n      break;\n    default:\n      throw new Error(\"unknown function\");\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMERBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQVc7QUFDakIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJEQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQWUsR0FBRyxDQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFlLEdBQUcsQ0FBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFIIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEhQXFxEZXNrdG9wXFxib29naWVib3QtbWFpblxcbmV4dC1zb2xhbmEtYXBwLXJvdXRlclxcbm9kZV9tb2R1bGVzXFx2YWx0aW9cXGVzbVxcdmFuaWxsYS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFya1RvVHJhY2ssIGdldFVudHJhY2tlZCB9IGZyb20gJ3Byb3h5LWNvbXBhcmUnO1xuXG5jb25zdCBpc09iamVjdCA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsO1xuY29uc3QgY2FuUHJveHlEZWZhdWx0ID0gKHgpID0+IGlzT2JqZWN0KHgpICYmICFyZWZTZXQuaGFzKHgpICYmIChBcnJheS5pc0FycmF5KHgpIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIHgpKSAmJiAhKHggaW5zdGFuY2VvZiBXZWFrTWFwKSAmJiAhKHggaW5zdGFuY2VvZiBXZWFrU2V0KSAmJiAhKHggaW5zdGFuY2VvZiBFcnJvcikgJiYgISh4IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhKHggaW5zdGFuY2VvZiBEYXRlKSAmJiAhKHggaW5zdGFuY2VvZiBTdHJpbmcpICYmICEoeCBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgISh4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmICEoeCBpbnN0YW5jZW9mIFByb21pc2UpO1xuY29uc3QgY3JlYXRlU25hcHNob3REZWZhdWx0ID0gKHRhcmdldCwgdmVyc2lvbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IHNuYXBDYWNoZS5nZXQodGFyZ2V0KTtcbiAgaWYgKChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGVbMF0pID09PSB2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlWzFdO1xuICB9XG4gIGNvbnN0IHNuYXAgPSBBcnJheS5pc0FycmF5KHRhcmdldCkgPyBbXSA6IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICBtYXJrVG9UcmFjayhzbmFwLCB0cnVlKTtcbiAgc25hcENhY2hlLnNldCh0YXJnZXQsIFt2ZXJzaW9uLCBzbmFwXSk7XG4gIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNuYXAsIGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgeyBlbnVtZXJhYmxlIH0gPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgICk7XG4gICAgY29uc3QgZGVzYyA9IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZW51bWVyYWJsZSxcbiAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgdG8gYXZvaWQgY29weWluZyB3aXRoIHByb3h5LWNvbXBhcmUuXG4gICAgICAvLyBJdCdzIHN0aWxsIG5vbi13cml0YWJsZSwgc28gaXQgYXZvaWRzIGFzc2lnbmluZyBhIHZhbHVlLlxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBpZiAocmVmU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgIG1hcmtUb1RyYWNrKHZhbHVlLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChwcm94eVN0YXRlTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IFt0YXJnZXQyLCBlbnN1cmVWZXJzaW9uXSA9IHByb3h5U3RhdGVNYXAuZ2V0KFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGRlc2MudmFsdWUgPSBjcmVhdGVTbmFwc2hvdERlZmF1bHQodGFyZ2V0MiwgZW5zdXJlVmVyc2lvbigpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNuYXAsIGtleSwgZGVzYyk7XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHNuYXApO1xufTtcbmNvbnN0IGNyZWF0ZUhhbmRsZXJEZWZhdWx0ID0gKGlzSW5pdGlhbGl6aW5nLCBhZGRQcm9wTGlzdGVuZXIsIHJlbW92ZVByb3BMaXN0ZW5lciwgbm90aWZ5VXBkYXRlKSA9PiAoe1xuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgIHJlbW92ZVByb3BMaXN0ZW5lcihwcm9wKTtcbiAgICBjb25zdCBkZWxldGVkID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICBub3RpZnlVcGRhdGUoW1wiZGVsZXRlXCIsIFtwcm9wXSwgcHJldlZhbHVlXSk7XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkO1xuICB9LFxuICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBjb25zdCBoYXNQcmV2VmFsdWUgPSAhaXNJbml0aWFsaXppbmcoKSAmJiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIGlmIChoYXNQcmV2VmFsdWUgJiYgKG9iamVjdElzKHByZXZWYWx1ZSwgdmFsdWUpIHx8IHByb3h5Q2FjaGUuaGFzKHZhbHVlKSAmJiBvYmplY3RJcyhwcmV2VmFsdWUsIHByb3h5Q2FjaGUuZ2V0KHZhbHVlKSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlUHJvcExpc3RlbmVyKHByb3ApO1xuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gZ2V0VW50cmFja2VkKHZhbHVlKSB8fCB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFZhbHVlID0gIXByb3h5U3RhdGVNYXAuaGFzKHZhbHVlKSAmJiBjYW5Qcm94eSh2YWx1ZSkgPyBwcm94eSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBhZGRQcm9wTGlzdGVuZXIocHJvcCwgbmV4dFZhbHVlKTtcbiAgICBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIG5leHRWYWx1ZSwgcmVjZWl2ZXIpO1xuICAgIG5vdGlmeVVwZGF0ZShbXCJzZXRcIiwgW3Byb3BdLCB2YWx1ZSwgcHJldlZhbHVlXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pO1xuY29uc3QgcHJveHlTdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVmU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jb25zdCBzbmFwQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHZlcnNpb25Ib2xkZXIgPSBbMSwgMV07XG5jb25zdCBwcm94eUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgb2JqZWN0SXMgPSBPYmplY3QuaXM7XG5sZXQgbmV3UHJveHkgPSAodGFyZ2V0LCBoYW5kbGVyKSA9PiBuZXcgUHJveHkodGFyZ2V0LCBoYW5kbGVyKTtcbmxldCBjYW5Qcm94eSA9IGNhblByb3h5RGVmYXVsdDtcbmxldCBjcmVhdGVTbmFwc2hvdCA9IGNyZWF0ZVNuYXBzaG90RGVmYXVsdDtcbmxldCBjcmVhdGVIYW5kbGVyID0gY3JlYXRlSGFuZGxlckRlZmF1bHQ7XG5mdW5jdGlvbiBwcm94eShiYXNlT2JqZWN0ID0ge30pIHtcbiAgaWYgKCFpc09iamVjdChiYXNlT2JqZWN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCByZXF1aXJlZFwiKTtcbiAgfVxuICBjb25zdCBmb3VuZCA9IHByb3h5Q2FjaGUuZ2V0KGJhc2VPYmplY3QpO1xuICBpZiAoZm91bmQpIHtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgbGV0IHZlcnNpb24gPSB2ZXJzaW9uSG9sZGVyWzBdO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBub3RpZnlVcGRhdGUgPSAob3AsIG5leHRWZXJzaW9uID0gKyt2ZXJzaW9uSG9sZGVyWzBdKSA9PiB7XG4gICAgaWYgKHZlcnNpb24gIT09IG5leHRWZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gbmV4dFZlcnNpb247XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKG9wLCBuZXh0VmVyc2lvbikpO1xuICAgIH1cbiAgfTtcbiAgbGV0IGNoZWNrVmVyc2lvbiA9IHZlcnNpb25Ib2xkZXJbMV07XG4gIGNvbnN0IGVuc3VyZVZlcnNpb24gPSAobmV4dENoZWNrVmVyc2lvbiA9ICsrdmVyc2lvbkhvbGRlclsxXSkgPT4ge1xuICAgIGlmIChjaGVja1ZlcnNpb24gIT09IG5leHRDaGVja1ZlcnNpb24gJiYgIWxpc3RlbmVycy5zaXplKSB7XG4gICAgICBjaGVja1ZlcnNpb24gPSBuZXh0Q2hlY2tWZXJzaW9uO1xuICAgICAgcHJvcFByb3h5U3RhdGVzLmZvckVhY2goKFtwcm9wUHJveHlTdGF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcFZlcnNpb24gPSBwcm9wUHJveHlTdGF0ZVsxXShuZXh0Q2hlY2tWZXJzaW9uKTtcbiAgICAgICAgaWYgKHByb3BWZXJzaW9uID4gdmVyc2lvbikge1xuICAgICAgICAgIHZlcnNpb24gPSBwcm9wVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9O1xuICBjb25zdCBjcmVhdGVQcm9wTGlzdGVuZXIgPSAocHJvcCkgPT4gKG9wLCBuZXh0VmVyc2lvbikgPT4ge1xuICAgIGNvbnN0IG5ld09wID0gWy4uLm9wXTtcbiAgICBuZXdPcFsxXSA9IFtwcm9wLCAuLi5uZXdPcFsxXV07XG4gICAgbm90aWZ5VXBkYXRlKG5ld09wLCBuZXh0VmVyc2lvbik7XG4gIH07XG4gIGNvbnN0IHByb3BQcm94eVN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGFkZFByb3BMaXN0ZW5lciA9IChwcm9wLCBwcm9wVmFsdWUpID0+IHtcbiAgICBjb25zdCBwcm9wUHJveHlTdGF0ZSA9ICFyZWZTZXQuaGFzKHByb3BWYWx1ZSkgJiYgcHJveHlTdGF0ZU1hcC5nZXQocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFByb3h5U3RhdGUpIHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9wUHJveHlTdGF0ZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb3AgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICB9XG4gICAgICBpZiAobGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gcHJvcFByb3h5U3RhdGVbMl0oY3JlYXRlUHJvcExpc3RlbmVyKHByb3ApKTtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcFByb3h5U3RhdGVzLnNldChwcm9wLCBbcHJvcFByb3h5U3RhdGVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZVByb3BMaXN0ZW5lciA9IChwcm9wKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVudHJ5ID0gcHJvcFByb3h5U3RhdGVzLmdldChwcm9wKTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5kZWxldGUocHJvcCk7XG4gICAgICAoX2EgPSBlbnRyeVsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZW50cnkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDEpIHtcbiAgICAgIHByb3BQcm94eVN0YXRlcy5mb3JFYWNoKChbcHJvcFByb3h5U3RhdGUsIHByZXZSZW1vdmVdLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcmV2UmVtb3ZlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IHByb3BQcm94eVN0YXRlWzJdKGNyZWF0ZVByb3BMaXN0ZW5lcihwcm9wKSk7XG4gICAgICAgIHByb3BQcm94eVN0YXRlcy5zZXQocHJvcCwgW3Byb3BQcm94eVN0YXRlLCByZW1vdmVdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgaWYgKGxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHByb3BQcm94eVN0YXRlcy5mb3JFYWNoKChbcHJvcFByb3h5U3RhdGUsIHJlbW92ZV0sIHByb3ApID0+IHtcbiAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgIHByb3BQcm94eVN0YXRlcy5zZXQocHJvcCwgW3Byb3BQcm94eVN0YXRlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbiAgfTtcbiAgbGV0IGluaXRpYWxpemluZyA9IHRydWU7XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKFxuICAgICgpID0+IGluaXRpYWxpemluZyxcbiAgICBhZGRQcm9wTGlzdGVuZXIsXG4gICAgcmVtb3ZlUHJvcExpc3RlbmVyLFxuICAgIG5vdGlmeVVwZGF0ZVxuICApO1xuICBjb25zdCBwcm94eU9iamVjdCA9IG5ld1Byb3h5KGJhc2VPYmplY3QsIGhhbmRsZXIpO1xuICBwcm94eUNhY2hlLnNldChiYXNlT2JqZWN0LCBwcm94eU9iamVjdCk7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBbYmFzZU9iamVjdCwgZW5zdXJlVmVyc2lvbiwgYWRkTGlzdGVuZXJdO1xuICBwcm94eVN0YXRlTWFwLnNldChwcm94eU9iamVjdCwgcHJveHlTdGF0ZSk7XG4gIFJlZmxlY3Qub3duS2V5cyhiYXNlT2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIGJhc2VPYmplY3QsXG4gICAgICBrZXlcbiAgICApO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzYyAmJiBkZXNjLndyaXRhYmxlKSB7XG4gICAgICBwcm94eU9iamVjdFtrZXldID0gYmFzZU9iamVjdFtrZXldO1xuICAgIH1cbiAgfSk7XG4gIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICByZXR1cm4gcHJveHlPYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRWZXJzaW9uKHByb3h5T2JqZWN0KSB7XG4gIGNvbnN0IHByb3h5U3RhdGUgPSBwcm94eVN0YXRlTWFwLmdldChwcm94eU9iamVjdCk7XG4gIHJldHVybiBwcm94eVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcm94eVN0YXRlWzFdKCk7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUocHJveHlPYmplY3QsIGNhbGxiYWNrLCBub3RpZnlJblN5bmMpIHtcbiAgY29uc3QgcHJveHlTdGF0ZSA9IHByb3h5U3RhdGVNYXAuZ2V0KHByb3h5T2JqZWN0KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFwcm94eVN0YXRlKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIHVzZSBwcm94eSBvYmplY3RcIik7XG4gIH1cbiAgbGV0IHByb21pc2U7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjb25zdCBhZGRMaXN0ZW5lciA9IHByb3h5U3RhdGVbMl07XG4gIGxldCBpc0xpc3RlbmVyQWN0aXZlID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVyID0gKG9wKSA9PiB7XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGlmIChub3RpZnlJblN5bmMpIHtcbiAgICAgIGNhbGxiYWNrKG9wcy5zcGxpY2UoMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzTGlzdGVuZXJBY3RpdmUpIHtcbiAgICAgICAgICBjYWxsYmFjayhvcHMuc3BsaWNlKDApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgaXNMaXN0ZW5lckFjdGl2ZSA9IHRydWU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaXNMaXN0ZW5lckFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gIH07XG59XG5mdW5jdGlvbiBzbmFwc2hvdChwcm94eU9iamVjdCkge1xuICBjb25zdCBwcm94eVN0YXRlID0gcHJveHlTdGF0ZU1hcC5nZXQocHJveHlPYmplY3QpO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIXByb3h5U3RhdGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgdXNlIHByb3h5IG9iamVjdFwiKTtcbiAgfVxuICBjb25zdCBbdGFyZ2V0LCBlbnN1cmVWZXJzaW9uXSA9IHByb3h5U3RhdGU7XG4gIHJldHVybiBjcmVhdGVTbmFwc2hvdCh0YXJnZXQsIGVuc3VyZVZlcnNpb24oKSk7XG59XG5mdW5jdGlvbiByZWYob2JqKSB7XG4gIHJlZlNldC5hZGQob2JqKTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEludGVybmFsU3RhdGVzKCkge1xuICByZXR1cm4ge1xuICAgIHByb3h5U3RhdGVNYXAsXG4gICAgcmVmU2V0LFxuICAgIHNuYXBDYWNoZSxcbiAgICB2ZXJzaW9uSG9sZGVyLFxuICAgIHByb3h5Q2FjaGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlcGxhY2VJbnRlcm5hbEZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgXCJvYmplY3RJc1wiOlxuICAgICAgb2JqZWN0SXMgPSBmbihvYmplY3RJcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibmV3UHJveHlcIjpcbiAgICAgIG5ld1Byb3h5ID0gZm4obmV3UHJveHkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhblByb3h5XCI6XG4gICAgICBjYW5Qcm94eSA9IGZuKGNhblByb3h5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVTbmFwc2hvdFwiOlxuICAgICAgY3JlYXRlU25hcHNob3QgPSBmbihjcmVhdGVTbmFwc2hvdCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlSGFuZGxlclwiOlxuICAgICAgY3JlYXRlSGFuZGxlciA9IGZuKGNyZWF0ZUhhbmRsZXIpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0VmVyc2lvbiwgcHJveHksIHJlZiwgc25hcHNob3QsIHN1YnNjcmliZSwgdW5zdGFibGVfZ2V0SW50ZXJuYWxTdGF0ZXMsIHVuc3RhYmxlX3JlcGxhY2VJbnRlcm5hbEZ1bmN0aW9uIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/valtio/esm/vanilla/utils.mjs":
/*!***************************************************!*\
  !*** ./node_modules/valtio/esm/vanilla/utils.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   devtools: () => (/* binding */ devtools),\n/* harmony export */   proxyMap: () => (/* binding */ proxyMap),\n/* harmony export */   proxySet: () => (/* binding */ proxySet),\n/* harmony export */   subscribeKey: () => (/* binding */ subscribeKey),\n/* harmony export */   watch: () => (/* binding */ watch)\n/* harmony export */ });\n/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! valtio/vanilla */ \"(ssr)/./node_modules/valtio/esm/vanilla.mjs\");\n\n\nfunction subscribeKey(proxyObject, key, callback, notifyInSync) {\n  let prevValue = proxyObject[key];\n  return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(\n    proxyObject,\n    () => {\n      const nextValue = proxyObject[key];\n      if (!Object.is(prevValue, nextValue)) {\n        callback(prevValue = nextValue);\n      }\n    },\n    notifyInSync\n  );\n}\n\nlet currentCleanups;\nfunction watch(callback, options) {\n  let alive = true;\n  const cleanups = /* @__PURE__ */ new Set();\n  const subscriptions = /* @__PURE__ */ new Map();\n  const cleanup = () => {\n    if (alive) {\n      alive = false;\n      cleanups.forEach((clean) => clean());\n      cleanups.clear();\n      subscriptions.forEach((unsubscribe) => unsubscribe());\n      subscriptions.clear();\n    }\n  };\n  const revalidate = async () => {\n    if (!alive) {\n      return;\n    }\n    cleanups.forEach((clean) => clean());\n    cleanups.clear();\n    const proxiesToSubscribe = /* @__PURE__ */ new Set();\n    const parent = currentCleanups;\n    currentCleanups = cleanups;\n    try {\n      const promiseOrPossibleCleanup = callback((proxyObject) => {\n        proxiesToSubscribe.add(proxyObject);\n        if (alive && !subscriptions.has(proxyObject)) {\n          const unsubscribe = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(proxyObject, revalidate, options == null ? void 0 : options.sync);\n          subscriptions.set(proxyObject, unsubscribe);\n        }\n        return proxyObject;\n      });\n      const couldBeCleanup = promiseOrPossibleCleanup && promiseOrPossibleCleanup instanceof Promise ? await promiseOrPossibleCleanup : promiseOrPossibleCleanup;\n      if (couldBeCleanup) {\n        if (alive) {\n          cleanups.add(couldBeCleanup);\n        } else {\n          cleanup();\n        }\n      }\n    } finally {\n      currentCleanups = parent;\n    }\n    subscriptions.forEach((unsubscribe, proxyObject) => {\n      if (!proxiesToSubscribe.has(proxyObject)) {\n        subscriptions.delete(proxyObject);\n        unsubscribe();\n      }\n    });\n  };\n  if (currentCleanups) {\n    currentCleanups.add(cleanup);\n  }\n  revalidate();\n  return cleanup;\n}\n\nconst DEVTOOLS = Symbol();\nfunction devtools(proxyObject, options) {\n  const { enabled, name = \"\", ...rest } = options || {};\n  let extension;\n  try {\n    extension = (enabled != null ? enabled : ( false ? 0 : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extension) {\n    if (( false ? 0 : void 0) !== \"production\" && enabled) {\n      console.warn(\"[Warning] Please install/enable Redux devtools extension\");\n    }\n    return;\n  }\n  let isTimeTraveling = false;\n  const devtools2 = extension.connect({ name, ...rest });\n  const unsub1 = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.subscribe)(proxyObject, (ops) => {\n    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(\".\")}`).join(\", \");\n    if (!action) {\n      return;\n    }\n    if (isTimeTraveling) {\n      isTimeTraveling = false;\n    } else {\n      const snapWithoutDevtools = Object.assign({}, (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n      delete snapWithoutDevtools[DEVTOOLS];\n      devtools2.send(\n        {\n          type: action,\n          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()\n        },\n        snapWithoutDevtools\n      );\n    }\n  });\n  const unsub2 = devtools2.subscribe((message) => {\n    var _a, _b, _c, _d, _e, _f;\n    if (message.type === \"ACTION\" && message.payload) {\n      try {\n        Object.assign(proxyObject, JSON.parse(message.payload));\n      } catch (e) {\n        console.error(\n          \"please dispatch a serializable value that JSON.parse() and proxy() support\\n\",\n          e\n        );\n      }\n    }\n    if (message.type === \"DISPATCH\" && message.state) {\n      if (((_a = message.payload) == null ? void 0 : _a.type) === \"JUMP_TO_ACTION\" || ((_b = message.payload) == null ? void 0 : _b.type) === \"JUMP_TO_STATE\") {\n        isTimeTraveling = true;\n        const state = JSON.parse(message.state);\n        Object.assign(proxyObject, state);\n      }\n      proxyObject[DEVTOOLS] = message;\n    } else if (message.type === \"DISPATCH\" && ((_c = message.payload) == null ? void 0 : _c.type) === \"COMMIT\") {\n      devtools2.init((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n    } else if (message.type === \"DISPATCH\" && ((_d = message.payload) == null ? void 0 : _d.type) === \"IMPORT_STATE\") {\n      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;\n      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];\n      isTimeTraveling = true;\n      computedStates.forEach(({ state }, index) => {\n        const action = actions[index] || \"No action found\";\n        Object.assign(proxyObject, state);\n        if (index === 0) {\n          devtools2.init((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n        } else {\n          devtools2.send(action, (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n        }\n      });\n    }\n  });\n  devtools2.init((0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.snapshot)(proxyObject));\n  return () => {\n    unsub1();\n    unsub2 == null ? void 0 : unsub2();\n  };\n}\n\nconst { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.unstable_getInternalStates)();\nconst isProxy$1 = (x) => proxyStateMap$1.has(x);\nconst isProxyMap = (obj) => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Map\" && proxyStateMap$1.has(obj);\n};\nfunction proxyMap(entries) {\n  const initialData = [];\n  let initialIndex = 0;\n  const indexMap = /* @__PURE__ */ new Map();\n  const snapMapCache = /* @__PURE__ */ new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache$1.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;\n  if (entries) {\n    if (typeof entries[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\n        \"proxyMap:\\n\tinitial state must be iterable\\n\t\ttip: structure should be [[key, value]]\"\n      );\n    }\n    for (const [key, value] of entries) {\n      indexMap.set(key, initialIndex);\n      initialData[initialIndex++] = value;\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy$1(this)) {\n        registerSnapMap();\n      }\n      const map = getMapForThis(this);\n      return map.size;\n    },\n    get(key) {\n      const map = getMapForThis(this);\n      const index = map.get(key);\n      if (index === void 0) {\n        this.epoch;\n        return void 0;\n      }\n      return this.data[index];\n    },\n    has(key) {\n      const map = getMapForThis(this);\n      this.epoch;\n      return map.has(key);\n    },\n    set(key, value) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        indexMap.set(key, this.index);\n        this.data[this.index++] = value;\n      } else {\n        this.data[index] = value;\n      }\n      this.epoch++;\n      return this;\n    },\n    delete(key) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(key);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index, key) => {\n        cb(this.data[index], key, this);\n      });\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const [key, index] of map) {\n        yield [key, this.data[index]];\n      }\n    },\n    *keys() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const key of map.keys()) {\n        yield key;\n      }\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    [Symbol.iterator]() {\n      return this.entries();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Map\";\n    },\n    toJSON() {\n      return new Map(this.entries());\n    }\n  };\n  const proxiedObject = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: { enumerable: false },\n    index: { enumerable: false },\n    epoch: { enumerable: false },\n    data: { enumerable: false },\n    toJSON: { enumerable: false }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\n\nconst { proxyStateMap, snapCache } = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.unstable_getInternalStates)();\nconst maybeProxify = (x) => typeof x === \"object\" ? (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)({ x }).x : x;\nconst isProxy = (x) => proxyStateMap.has(x);\nconst isProxySet = (obj) => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Set\" && proxyStateMap.has(obj);\n};\nfunction proxySet(initialValues) {\n  const initialData = [];\n  const indexMap = /* @__PURE__ */ new Map();\n  let initialIndex = 0;\n  const snapMapCache = /* @__PURE__ */ new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;\n  if (initialValues) {\n    if (typeof initialValues[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\"not iterable\");\n    }\n    for (const value of initialValues) {\n      if (!indexMap.has(value)) {\n        const v = maybeProxify(value);\n        indexMap.set(v, initialIndex);\n        initialData[initialIndex++] = v;\n      }\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy(this)) {\n        registerSnapMap();\n      }\n      return indexMap.size;\n    },\n    has(value) {\n      const map = getMapForThis(this);\n      const v = maybeProxify(value);\n      this.epoch;\n      return map.has(v);\n    },\n    add(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      if (!indexMap.has(v)) {\n        indexMap.set(v, this.index);\n        this.data[this.index++] = v;\n        this.epoch++;\n      }\n      return this;\n    },\n    delete(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      const index = indexMap.get(v);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(v);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index) => {\n        cb(this.data[index], this.data[index], this);\n      });\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    keys() {\n      this.epoch;\n      return this.values();\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        const value = this.data[index];\n        yield [value, value];\n      }\n    },\n    toJSON() {\n      return new Set(this.values());\n    },\n    [Symbol.iterator]() {\n      return this.values();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Set\";\n    },\n    intersection(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      const resultSet = proxySet();\n      for (const value of this.values()) {\n        if (otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    union(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        resultSet.add(value);\n      }\n      for (const value of otherSet) {\n        resultSet.add(value);\n      }\n      return proxySet(resultSet);\n    },\n    difference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    symmetricDifference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      for (const value of otherSet.values()) {\n        if (!this.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    isSubsetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size <= other.size && [...this.values()].every((value) => otherSet.has(value));\n    },\n    isSupersetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size >= other.size && [...otherSet].every((value) => this.has(value));\n    },\n    isDisjointFrom(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return [...this.values()].every((value) => !otherSet.has(value));\n    }\n  };\n  const proxiedObject = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.proxy)(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: { enumerable: false },\n    data: { enumerable: false },\n    index: { enumerable: false },\n    epoch: { enumerable: false },\n    toJSON: { enumerable: false }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nlet defaultRefSet;\nconst getDefaultRefSet = () => {\n  if (!defaultRefSet) {\n    defaultRefSet = (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_0__.unstable_getInternalStates)().refSet;\n  }\n  return defaultRefSet;\n};\nfunction deepClone(obj, getRefSet = getDefaultRefSet) {\n  if (!isObject(obj) || getRefSet().has(obj)) {\n    return obj;\n  }\n  if (isProxySet(obj)) {\n    return proxySet([...obj]);\n  }\n  if (isProxyMap(obj)) {\n    return proxyMap([\n      ...obj.entries()\n    ]);\n  }\n  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n  Reflect.ownKeys(obj).forEach((key) => {\n    baseObject[key] = deepClone(obj[key], getRefSet);\n  });\n  return baseObject;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsdGlvL2VzbS92YW5pbGxhL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdGOztBQUV4RjtBQUNBO0FBQ0EsU0FBUyx5REFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0EsOENBQThDLE1BQWUsR0FBRyxDQUFvQjtBQUNwRixJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCxpQkFBaUIseURBQVM7QUFDMUIsMEZBQTBGLEdBQUcsR0FBRywyQkFBMkI7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsRUFBRSx3REFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQix3REFBUTtBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdEQUFRO0FBQ2pDLFVBQVU7QUFDVixpQ0FBaUMsd0RBQVE7QUFDekM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLHdEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx5REFBeUQsRUFBRSwwRUFBMEI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQUs7QUFDN0I7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQjtBQUNoQyxZQUFZLG1CQUFtQjtBQUMvQixjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDJCQUEyQixFQUFFLDBFQUEwQjtBQUMvRCxvREFBb0QscURBQUssR0FBRyxHQUFHO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBSztBQUM3QjtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksbUJBQW1CO0FBQy9CLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1CO0FBQ2hDLGNBQWM7QUFDZCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBFQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFd0UiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSFBcXERlc2t0b3BcXGJvb2dpZWJvdC1tYWluXFxuZXh0LXNvbGFuYS1hcHAtcm91dGVyXFxub2RlX21vZHVsZXNcXHZhbHRpb1xcZXNtXFx2YW5pbGxhXFx1dGlscy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Vic2NyaWJlLCBzbmFwc2hvdCwgdW5zdGFibGVfZ2V0SW50ZXJuYWxTdGF0ZXMsIHByb3h5IH0gZnJvbSAndmFsdGlvL3ZhbmlsbGEnO1xuXG5mdW5jdGlvbiBzdWJzY3JpYmVLZXkocHJveHlPYmplY3QsIGtleSwgY2FsbGJhY2ssIG5vdGlmeUluU3luYykge1xuICBsZXQgcHJldlZhbHVlID0gcHJveHlPYmplY3Rba2V5XTtcbiAgcmV0dXJuIHN1YnNjcmliZShcbiAgICBwcm94eU9iamVjdCxcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBwcm94eU9iamVjdFtrZXldO1xuICAgICAgaWYgKCFPYmplY3QuaXMocHJldlZhbHVlLCBuZXh0VmFsdWUpKSB7XG4gICAgICAgIGNhbGxiYWNrKHByZXZWYWx1ZSA9IG5leHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3RpZnlJblN5bmNcbiAgKTtcbn1cblxubGV0IGN1cnJlbnRDbGVhbnVwcztcbmZ1bmN0aW9uIHdhdGNoKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCBhbGl2ZSA9IHRydWU7XG4gIGNvbnN0IGNsZWFudXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgaWYgKGFsaXZlKSB7XG4gICAgICBhbGl2ZSA9IGZhbHNlO1xuICAgICAgY2xlYW51cHMuZm9yRWFjaCgoY2xlYW4pID0+IGNsZWFuKCkpO1xuICAgICAgY2xlYW51cHMuY2xlYXIoKTtcbiAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICAgICAgc3Vic2NyaXB0aW9ucy5jbGVhcigpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmV2YWxpZGF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWFsaXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFudXBzLmZvckVhY2goKGNsZWFuKSA9PiBjbGVhbigpKTtcbiAgICBjbGVhbnVwcy5jbGVhcigpO1xuICAgIGNvbnN0IHByb3hpZXNUb1N1YnNjcmliZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgcGFyZW50ID0gY3VycmVudENsZWFudXBzO1xuICAgIGN1cnJlbnRDbGVhbnVwcyA9IGNsZWFudXBzO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlT3JQb3NzaWJsZUNsZWFudXAgPSBjYWxsYmFjaygocHJveHlPYmplY3QpID0+IHtcbiAgICAgICAgcHJveGllc1RvU3Vic2NyaWJlLmFkZChwcm94eU9iamVjdCk7XG4gICAgICAgIGlmIChhbGl2ZSAmJiAhc3Vic2NyaXB0aW9ucy5oYXMocHJveHlPYmplY3QpKSB7XG4gICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUocHJveHlPYmplY3QsIHJldmFsaWRhdGUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3luYyk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5zZXQocHJveHlPYmplY3QsIHVuc3Vic2NyaWJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJveHlPYmplY3Q7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNvdWxkQmVDbGVhbnVwID0gcHJvbWlzZU9yUG9zc2libGVDbGVhbnVwICYmIHByb21pc2VPclBvc3NpYmxlQ2xlYW51cCBpbnN0YW5jZW9mIFByb21pc2UgPyBhd2FpdCBwcm9taXNlT3JQb3NzaWJsZUNsZWFudXAgOiBwcm9taXNlT3JQb3NzaWJsZUNsZWFudXA7XG4gICAgICBpZiAoY291bGRCZUNsZWFudXApIHtcbiAgICAgICAgaWYgKGFsaXZlKSB7XG4gICAgICAgICAgY2xlYW51cHMuYWRkKGNvdWxkQmVDbGVhbnVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudENsZWFudXBzID0gcGFyZW50O1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKHVuc3Vic2NyaWJlLCBwcm94eU9iamVjdCkgPT4ge1xuICAgICAgaWYgKCFwcm94aWVzVG9TdWJzY3JpYmUuaGFzKHByb3h5T2JqZWN0KSkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmRlbGV0ZShwcm94eU9iamVjdCk7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGlmIChjdXJyZW50Q2xlYW51cHMpIHtcbiAgICBjdXJyZW50Q2xlYW51cHMuYWRkKGNsZWFudXApO1xuICB9XG4gIHJldmFsaWRhdGUoKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbmNvbnN0IERFVlRPT0xTID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkZXZ0b29scyhwcm94eU9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCB7IGVuYWJsZWQsIG5hbWUgPSBcIlwiLCAuLi5yZXN0IH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgZXh0ZW5zaW9uO1xuICB0cnkge1xuICAgIGV4dGVuc2lvbiA9IChlbmFibGVkICE9IG51bGwgPyBlbmFibGVkIDogKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW5hYmxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1dhcm5pbmddIFBsZWFzZSBpbnN0YWxsL2VuYWJsZSBSZWR1eCBkZXZ0b29scyBleHRlbnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBsZXQgaXNUaW1lVHJhdmVsaW5nID0gZmFsc2U7XG4gIGNvbnN0IGRldnRvb2xzMiA9IGV4dGVuc2lvbi5jb25uZWN0KHsgbmFtZSwgLi4ucmVzdCB9KTtcbiAgY29uc3QgdW5zdWIxID0gc3Vic2NyaWJlKHByb3h5T2JqZWN0LCAob3BzKSA9PiB7XG4gICAgY29uc3QgYWN0aW9uID0gb3BzLmZpbHRlcigoW18sIHBhdGhdKSA9PiBwYXRoWzBdICE9PSBERVZUT09MUykubWFwKChbb3AsIHBhdGhdKSA9PiBgJHtvcH06JHtwYXRoLm1hcChTdHJpbmcpLmpvaW4oXCIuXCIpfWApLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNUaW1lVHJhdmVsaW5nKSB7XG4gICAgICBpc1RpbWVUcmF2ZWxpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc25hcFdpdGhvdXREZXZ0b29scyA9IE9iamVjdC5hc3NpZ24oe30sIHNuYXBzaG90KHByb3h5T2JqZWN0KSk7XG4gICAgICBkZWxldGUgc25hcFdpdGhvdXREZXZ0b29sc1tERVZUT09MU107XG4gICAgICBkZXZ0b29sczIuc2VuZChcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IGFjdGlvbixcbiAgICAgICAgICB1cGRhdGVkQXQ6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9Mb2NhbGVTdHJpbmcoKVxuICAgICAgICB9LFxuICAgICAgICBzbmFwV2l0aG91dERldnRvb2xzXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHVuc3ViMiA9IGRldnRvb2xzMi5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBpZiAobWVzc2FnZS50eXBlID09PSBcIkFDVElPTlwiICYmIG1lc3NhZ2UucGF5bG9hZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm94eU9iamVjdCwgSlNPTi5wYXJzZShtZXNzYWdlLnBheWxvYWQpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcInBsZWFzZSBkaXNwYXRjaCBhIHNlcmlhbGl6YWJsZSB2YWx1ZSB0aGF0IEpTT04ucGFyc2UoKSBhbmQgcHJveHkoKSBzdXBwb3J0XFxuXCIsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVzc2FnZS50eXBlID09PSBcIkRJU1BBVENIXCIgJiYgbWVzc2FnZS5zdGF0ZSkge1xuICAgICAgaWYgKCgoX2EgPSBtZXNzYWdlLnBheWxvYWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJKVU1QX1RPX0FDVElPTlwiIHx8ICgoX2IgPSBtZXNzYWdlLnBheWxvYWQpID09IG51bGwgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gXCJKVU1QX1RPX1NUQVRFXCIpIHtcbiAgICAgICAgaXNUaW1lVHJhdmVsaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKG1lc3NhZ2Uuc3RhdGUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3h5T2JqZWN0LCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBwcm94eU9iamVjdFtERVZUT09MU10gPSBtZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcIkRJU1BBVENIXCIgJiYgKChfYyA9IG1lc3NhZ2UucGF5bG9hZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnR5cGUpID09PSBcIkNPTU1JVFwiKSB7XG4gICAgICBkZXZ0b29sczIuaW5pdChzbmFwc2hvdChwcm94eU9iamVjdCkpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcIkRJU1BBVENIXCIgJiYgKChfZCA9IG1lc3NhZ2UucGF5bG9hZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnR5cGUpID09PSBcIklNUE9SVF9TVEFURVwiKSB7XG4gICAgICBjb25zdCBhY3Rpb25zID0gKF9lID0gbWVzc2FnZS5wYXlsb2FkLm5leHRMaWZ0ZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmFjdGlvbnNCeUlkO1xuICAgICAgY29uc3QgY29tcHV0ZWRTdGF0ZXMgPSAoKF9mID0gbWVzc2FnZS5wYXlsb2FkLm5leHRMaWZ0ZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNvbXB1dGVkU3RhdGVzKSB8fCBbXTtcbiAgICAgIGlzVGltZVRyYXZlbGluZyA9IHRydWU7XG4gICAgICBjb21wdXRlZFN0YXRlcy5mb3JFYWNoKCh7IHN0YXRlIH0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbaW5kZXhdIHx8IFwiTm8gYWN0aW9uIGZvdW5kXCI7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJveHlPYmplY3QsIHN0YXRlKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgZGV2dG9vbHMyLmluaXQoc25hcHNob3QocHJveHlPYmplY3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXZ0b29sczIuc2VuZChhY3Rpb24sIHNuYXBzaG90KHByb3h5T2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGRldnRvb2xzMi5pbml0KHNuYXBzaG90KHByb3h5T2JqZWN0KSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdW5zdWIxKCk7XG4gICAgdW5zdWIyID09IG51bGwgPyB2b2lkIDAgOiB1bnN1YjIoKTtcbiAgfTtcbn1cblxuY29uc3QgeyBwcm94eVN0YXRlTWFwOiBwcm94eVN0YXRlTWFwJDEsIHNuYXBDYWNoZTogc25hcENhY2hlJDEgfSA9IHVuc3RhYmxlX2dldEludGVybmFsU3RhdGVzKCk7XG5jb25zdCBpc1Byb3h5JDEgPSAoeCkgPT4gcHJveHlTdGF0ZU1hcCQxLmhhcyh4KTtcbmNvbnN0IGlzUHJveHlNYXAgPSAob2JqKSA9PiB7XG4gIHJldHVybiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gb2JqICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIk1hcFwiICYmIHByb3h5U3RhdGVNYXAkMS5oYXMob2JqKTtcbn07XG5mdW5jdGlvbiBwcm94eU1hcChlbnRyaWVzKSB7XG4gIGNvbnN0IGluaXRpYWxEYXRhID0gW107XG4gIGxldCBpbml0aWFsSW5kZXggPSAwO1xuICBjb25zdCBpbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHNuYXBNYXBDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCByZWdpc3RlclNuYXBNYXAgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBzbmFwQ2FjaGUkMS5nZXQodk9iamVjdCk7XG4gICAgY29uc3QgbGF0ZXN0U25hcCA9IGNhY2hlID09IG51bGwgPyB2b2lkIDAgOiBjYWNoZVsxXTtcbiAgICBpZiAobGF0ZXN0U25hcCAmJiAhc25hcE1hcENhY2hlLmhhcyhsYXRlc3RTbmFwKSkge1xuICAgICAgY29uc3QgY2xvbmVkTWFwID0gbmV3IE1hcChpbmRleE1hcCk7XG4gICAgICBzbmFwTWFwQ2FjaGUuc2V0KGxhdGVzdFNuYXAsIGNsb25lZE1hcCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRNYXBGb3JUaGlzID0gKHgpID0+IHNuYXBNYXBDYWNoZS5nZXQoeCkgfHwgaW5kZXhNYXA7XG4gIGlmIChlbnRyaWVzKSB7XG4gICAgaWYgKHR5cGVvZiBlbnRyaWVzW1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJwcm94eU1hcDpcXG5cdGluaXRpYWwgc3RhdGUgbXVzdCBiZSBpdGVyYWJsZVxcblx0XHR0aXA6IHN0cnVjdHVyZSBzaG91bGQgYmUgW1trZXksIHZhbHVlXV1cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgaW5kZXhNYXAuc2V0KGtleSwgaW5pdGlhbEluZGV4KTtcbiAgICAgIGluaXRpYWxEYXRhW2luaXRpYWxJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBjb25zdCB2T2JqZWN0ID0ge1xuICAgIGRhdGE6IGluaXRpYWxEYXRhLFxuICAgIGluZGV4OiBpbml0aWFsSW5kZXgsXG4gICAgZXBvY2g6IDAsXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICBpZiAoIWlzUHJveHkkMSh0aGlzKSkge1xuICAgICAgICByZWdpc3RlclNuYXBNYXAoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcCA9IGdldE1hcEZvclRoaXModGhpcyk7XG4gICAgICByZXR1cm4gbWFwLnNpemU7XG4gICAgfSxcbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBtYXAgPSBnZXRNYXBGb3JUaGlzKHRoaXMpO1xuICAgICAgY29uc3QgaW5kZXggPSBtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmVwb2NoO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICBjb25zdCBtYXAgPSBnZXRNYXBGb3JUaGlzKHRoaXMpO1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIHJldHVybiBtYXAuaGFzKGtleSk7XG4gICAgfSxcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCFpc1Byb3h5JDEodGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gbXV0YXRpb25zIG9uIGEgc25hcHNob3RcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IGluZGV4TWFwLmdldChrZXkpO1xuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXhNYXAuc2V0KGtleSwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmluZGV4KytdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVwb2NoKys7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGlmICghaXNQcm94eSQxKHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG11dGF0aW9ucyBvbiBhIHNuYXBzaG90XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE1hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgaW5kZXhNYXAuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmVwb2NoKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgaWYgKCFpc1Byb3h5JDEodGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gbXV0YXRpb25zIG9uIGEgc25hcHNob3RcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5lcG9jaCsrO1xuICAgICAgaW5kZXhNYXAuY2xlYXIoKTtcbiAgICB9LFxuICAgIGZvckVhY2goY2IpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICBjb25zdCBtYXAgPSBnZXRNYXBGb3JUaGlzKHRoaXMpO1xuICAgICAgbWFwLmZvckVhY2goKGluZGV4LCBrZXkpID0+IHtcbiAgICAgICAgY2IodGhpcy5kYXRhW2luZGV4XSwga2V5LCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgKmVudHJpZXMoKSB7XG4gICAgICB0aGlzLmVwb2NoO1xuICAgICAgY29uc3QgbWFwID0gZ2V0TWFwRm9yVGhpcyh0aGlzKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgaW5kZXhdIG9mIG1hcCkge1xuICAgICAgICB5aWVsZCBba2V5LCB0aGlzLmRhdGFbaW5kZXhdXTtcbiAgICAgIH1cbiAgICB9LFxuICAgICprZXlzKCkge1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIGNvbnN0IG1hcCA9IGdldE1hcEZvclRoaXModGhpcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBtYXAua2V5cygpKSB7XG4gICAgICAgIHlpZWxkIGtleTtcbiAgICAgIH1cbiAgICB9LFxuICAgICp2YWx1ZXMoKSB7XG4gICAgICB0aGlzLmVwb2NoO1xuICAgICAgY29uc3QgbWFwID0gZ2V0TWFwRm9yVGhpcyh0aGlzKTtcbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpbmRleF07XG4gICAgICB9XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9LFxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgIHJldHVybiBcIk1hcFwiO1xuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXAodGhpcy5lbnRyaWVzKCkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJveGllZE9iamVjdCA9IHByb3h5KHZPYmplY3QpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm94aWVkT2JqZWN0LCB7XG4gICAgc2l6ZTogeyBlbnVtZXJhYmxlOiBmYWxzZSB9LFxuICAgIGluZGV4OiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgZXBvY2g6IHsgZW51bWVyYWJsZTogZmFsc2UgfSxcbiAgICBkYXRhOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgdG9KU09OOiB7IGVudW1lcmFibGU6IGZhbHNlIH1cbiAgfSk7XG4gIE9iamVjdC5zZWFsKHByb3hpZWRPYmplY3QpO1xuICByZXR1cm4gcHJveGllZE9iamVjdDtcbn1cblxuY29uc3QgeyBwcm94eVN0YXRlTWFwLCBzbmFwQ2FjaGUgfSA9IHVuc3RhYmxlX2dldEludGVybmFsU3RhdGVzKCk7XG5jb25zdCBtYXliZVByb3hpZnkgPSAoeCkgPT4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgPyBwcm94eSh7IHggfSkueCA6IHg7XG5jb25zdCBpc1Byb3h5ID0gKHgpID0+IHByb3h5U3RhdGVNYXAuaGFzKHgpO1xuY29uc3QgaXNQcm94eVNldCA9IChvYmopID0+IHtcbiAgcmV0dXJuIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBvYmogJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiU2V0XCIgJiYgcHJveHlTdGF0ZU1hcC5oYXMob2JqKTtcbn07XG5mdW5jdGlvbiBwcm94eVNldChpbml0aWFsVmFsdWVzKSB7XG4gIGNvbnN0IGluaXRpYWxEYXRhID0gW107XG4gIGNvbnN0IGluZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGluaXRpYWxJbmRleCA9IDA7XG4gIGNvbnN0IHNuYXBNYXBDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCByZWdpc3RlclNuYXBNYXAgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBzbmFwQ2FjaGUuZ2V0KHZPYmplY3QpO1xuICAgIGNvbnN0IGxhdGVzdFNuYXAgPSBjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGVbMV07XG4gICAgaWYgKGxhdGVzdFNuYXAgJiYgIXNuYXBNYXBDYWNoZS5oYXMobGF0ZXN0U25hcCkpIHtcbiAgICAgIGNvbnN0IGNsb25lZE1hcCA9IG5ldyBNYXAoaW5kZXhNYXApO1xuICAgICAgc25hcE1hcENhY2hlLnNldChsYXRlc3RTbmFwLCBjbG9uZWRNYXApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0TWFwRm9yVGhpcyA9ICh4KSA9PiBzbmFwTWFwQ2FjaGUuZ2V0KHgpIHx8IGluZGV4TWFwO1xuICBpZiAoaW5pdGlhbFZhbHVlcykge1xuICAgIGlmICh0eXBlb2YgaW5pdGlhbFZhbHVlc1tTeW1ib2wuaXRlcmF0b3JdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgaXRlcmFibGVcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaW5pdGlhbFZhbHVlcykge1xuICAgICAgaWYgKCFpbmRleE1hcC5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHYgPSBtYXliZVByb3hpZnkodmFsdWUpO1xuICAgICAgICBpbmRleE1hcC5zZXQodiwgaW5pdGlhbEluZGV4KTtcbiAgICAgICAgaW5pdGlhbERhdGFbaW5pdGlhbEluZGV4KytdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgdk9iamVjdCA9IHtcbiAgICBkYXRhOiBpbml0aWFsRGF0YSxcbiAgICBpbmRleDogaW5pdGlhbEluZGV4LFxuICAgIGVwb2NoOiAwLFxuICAgIGdldCBzaXplKCkge1xuICAgICAgaWYgKCFpc1Byb3h5KHRoaXMpKSB7XG4gICAgICAgIHJlZ2lzdGVyU25hcE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4TWFwLnNpemU7XG4gICAgfSxcbiAgICBoYXModmFsdWUpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGdldE1hcEZvclRoaXModGhpcyk7XG4gICAgICBjb25zdCB2ID0gbWF5YmVQcm94aWZ5KHZhbHVlKTtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICByZXR1cm4gbWFwLmhhcyh2KTtcbiAgICB9LFxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc1Byb3h5KHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG11dGF0aW9ucyBvbiBhIHNuYXBzaG90XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdiA9IG1heWJlUHJveGlmeSh2YWx1ZSk7XG4gICAgICBpZiAoIWluZGV4TWFwLmhhcyh2KSkge1xuICAgICAgICBpbmRleE1hcC5zZXQodiwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmluZGV4KytdID0gdjtcbiAgICAgICAgdGhpcy5lcG9jaCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWxldGUodmFsdWUpIHtcbiAgICAgIGlmICghaXNQcm94eSh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGVyZm9ybSBtdXRhdGlvbnMgb24gYSBzbmFwc2hvdFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHYgPSBtYXliZVByb3hpZnkodmFsdWUpO1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE1hcC5nZXQodik7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgIGluZGV4TWFwLmRlbGV0ZSh2KTtcbiAgICAgIHRoaXMuZXBvY2grKztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBpZiAoIWlzUHJveHkodGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gbXV0YXRpb25zIG9uIGEgc25hcHNob3RcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5lcG9jaCsrO1xuICAgICAgaW5kZXhNYXAuY2xlYXIoKTtcbiAgICB9LFxuICAgIGZvckVhY2goY2IpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICBjb25zdCBtYXAgPSBnZXRNYXBGb3JUaGlzKHRoaXMpO1xuICAgICAgbWFwLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICAgIGNiKHRoaXMuZGF0YVtpbmRleF0sIHRoaXMuZGF0YVtpbmRleF0sIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAqdmFsdWVzKCkge1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIGNvbnN0IG1hcCA9IGdldE1hcEZvclRoaXModGhpcyk7XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgfVxuICAgIH0sXG4gICAga2V5cygpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9LFxuICAgICplbnRyaWVzKCkge1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIGNvbnN0IG1hcCA9IGdldE1hcEZvclRoaXModGhpcyk7XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgIHlpZWxkIFt2YWx1ZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy52YWx1ZXMoKSk7XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH0sXG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgcmV0dXJuIFwiU2V0XCI7XG4gICAgfSxcbiAgICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICBjb25zdCBvdGhlclNldCA9IHByb3h5U2V0KG90aGVyKTtcbiAgICAgIGNvbnN0IHJlc3VsdFNldCA9IHByb3h5U2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG90aGVyU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHRTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3h5U2V0KHJlc3VsdFNldCk7XG4gICAgfSxcbiAgICB1bmlvbihvdGhlcikge1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIGNvbnN0IHJlc3VsdFNldCA9IHByb3h5U2V0KCk7XG4gICAgICBjb25zdCBvdGhlclNldCA9IHByb3h5U2V0KG90aGVyKTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgICByZXN1bHRTZXQuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb3RoZXJTZXQpIHtcbiAgICAgICAgcmVzdWx0U2V0LmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJveHlTZXQocmVzdWx0U2V0KTtcbiAgICB9LFxuICAgIGRpZmZlcmVuY2Uob3RoZXIpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICBjb25zdCByZXN1bHRTZXQgPSBwcm94eVNldCgpO1xuICAgICAgY29uc3Qgb3RoZXJTZXQgPSBwcm94eVNldChvdGhlcik7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKCFvdGhlclNldC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm94eVNldChyZXN1bHRTZXQpO1xuICAgIH0sXG4gICAgc3ltbWV0cmljRGlmZmVyZW5jZShvdGhlcikge1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIGNvbnN0IHJlc3VsdFNldCA9IHByb3h5U2V0KCk7XG4gICAgICBjb25zdCBvdGhlclNldCA9IHByb3h5U2V0KG90aGVyKTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIW90aGVyU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHRTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvdGhlclNldC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdFNldC5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJveHlTZXQocmVzdWx0U2V0KTtcbiAgICB9LFxuICAgIGlzU3Vic2V0T2Yob3RoZXIpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICBjb25zdCBvdGhlclNldCA9IHByb3h5U2V0KG90aGVyKTtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgPD0gb3RoZXIuc2l6ZSAmJiBbLi4udGhpcy52YWx1ZXMoKV0uZXZlcnkoKHZhbHVlKSA9PiBvdGhlclNldC5oYXModmFsdWUpKTtcbiAgICB9LFxuICAgIGlzU3VwZXJzZXRPZihvdGhlcikge1xuICAgICAgdGhpcy5lcG9jaDtcbiAgICAgIGNvbnN0IG90aGVyU2V0ID0gcHJveHlTZXQob3RoZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA+PSBvdGhlci5zaXplICYmIFsuLi5vdGhlclNldF0uZXZlcnkoKHZhbHVlKSA9PiB0aGlzLmhhcyh2YWx1ZSkpO1xuICAgIH0sXG4gICAgaXNEaXNqb2ludEZyb20ob3RoZXIpIHtcbiAgICAgIHRoaXMuZXBvY2g7XG4gICAgICBjb25zdCBvdGhlclNldCA9IHByb3h5U2V0KG90aGVyKTtcbiAgICAgIHJldHVybiBbLi4udGhpcy52YWx1ZXMoKV0uZXZlcnkoKHZhbHVlKSA9PiAhb3RoZXJTZXQuaGFzKHZhbHVlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm94aWVkT2JqZWN0ID0gcHJveHkodk9iamVjdCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3hpZWRPYmplY3QsIHtcbiAgICBzaXplOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgZGF0YTogeyBlbnVtZXJhYmxlOiBmYWxzZSB9LFxuICAgIGluZGV4OiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgZXBvY2g6IHsgZW51bWVyYWJsZTogZmFsc2UgfSxcbiAgICB0b0pTT046IHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICB9KTtcbiAgT2JqZWN0LnNlYWwocHJveGllZE9iamVjdCk7XG4gIHJldHVybiBwcm94aWVkT2JqZWN0O1xufVxuXG5jb25zdCBpc09iamVjdCA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsO1xubGV0IGRlZmF1bHRSZWZTZXQ7XG5jb25zdCBnZXREZWZhdWx0UmVmU2V0ID0gKCkgPT4ge1xuICBpZiAoIWRlZmF1bHRSZWZTZXQpIHtcbiAgICBkZWZhdWx0UmVmU2V0ID0gdW5zdGFibGVfZ2V0SW50ZXJuYWxTdGF0ZXMoKS5yZWZTZXQ7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRSZWZTZXQ7XG59O1xuZnVuY3Rpb24gZGVlcENsb25lKG9iaiwgZ2V0UmVmU2V0ID0gZ2V0RGVmYXVsdFJlZlNldCkge1xuICBpZiAoIWlzT2JqZWN0KG9iaikgfHwgZ2V0UmVmU2V0KCkuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChpc1Byb3h5U2V0KG9iaikpIHtcbiAgICByZXR1cm4gcHJveHlTZXQoWy4uLm9ial0pO1xuICB9XG4gIGlmIChpc1Byb3h5TWFwKG9iaikpIHtcbiAgICByZXR1cm4gcHJveHlNYXAoW1xuICAgICAgLi4ub2JqLmVudHJpZXMoKVxuICAgIF0pO1xuICB9XG4gIGNvbnN0IGJhc2VPYmplY3QgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuICBSZWZsZWN0Lm93bktleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBiYXNlT2JqZWN0W2tleV0gPSBkZWVwQ2xvbmUob2JqW2tleV0sIGdldFJlZlNldCk7XG4gIH0pO1xuICByZXR1cm4gYmFzZU9iamVjdDtcbn1cblxuZXhwb3J0IHsgZGVlcENsb25lLCBkZXZ0b29scywgcHJveHlNYXAsIHByb3h5U2V0LCBzdWJzY3JpYmVLZXksIHdhdGNoIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valtio/esm/vanilla/utils.mjs\n");

/***/ })

};
;